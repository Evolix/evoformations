<!doctype html>
<html lang="fr">

    <head>
        <meta charset="utf-8">

        <title>Formation Evolix : administration système et réseau</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

            <section>
            <h1>Formation Evolix</h1>
            <h3>Administration système &amp; réseau &amp; sécurité</h3>
            </section>

<section>
<h2>Cron</h2>
	<pre>Les fichiers de cron</pre>
	<pre>
		<code>
# systemctl status cron
# vim /etc/crontab
# vim /etc/default/cron
		</code>
	</pre>
	<pre>
	<code>
# vim /etc/cron.d/example
	</code>
30 05 * * 0 www-data /usr/local/adm/savelog-weekly
</pre>
</section>

<section>
<pre>
<code>
$ crontab -e
</code>
</pre>
<pre>
<code>
# crontab -u jdoe -e
</code>
0,30,45,51 * * * * /usr/local/adm/send-data
*/15 * * * * /usr/local/adm/check-nis 1>/dev/null 2>&1
00 01 * * * nice -10 find /inf -name core -exec rm -f {} \;
10 03 * * 1-6 nice -10 /usr/local/adm/sauvegarde-daily
30 05 * * 0 /usr/local/adm/savelog-weekly
30 06 1 * * /usr/local/adm/savelog-monthly
00 00 1 1 * /usr/local/bin/happy-new-year
MAILTO=alert@example.com
@daily /usr/local/bin/minuit-check
</pre>
</section>

<section>
<pre>
<code>
$ man 5 crontab
</code>
<code>
$ crontab -l
</code>
<code>
# crontab -u jdoe -l
</code>
</section>

<section>

<h2>ntpd</h2>
$ date
# apt install ntp

Fichier /etc/ntp.conf :
server ntp.evolix.net

# ntpq -p

$ timedatectl
# hwclock --show
# hwclock --systohc
</section>

<section>
<h2>systemd</h2>
systemd est un gestionnaire de services (le fameux démon avec le PID 1) en alternative au System V. Il est installé par défaut depuis Debian 8.

# systemctl status
# systemctl list-units
# systemctl --failed
# systemctl list-unit-files

Unités par défaut : /usr/lib/systemd/system/
Modifications manuelles : /etc/systemd/system/

# systemctl start <unité>
# systemctl stop <unité>
# systemctl restart <unité>
# systemctl reload <unité>

# systemctl status <unité>
# systemctl is-enabled <unité>

# systemctl enable <unité>
# systemctl disable <unité>

# systemctl reboot
# systemctl poweroff
# systemd-analyze

Modifier une unité

# cp -a /lib/systemd/system/<service>.service /etc/systemd/system/
# vim /etc/systemd/system/<service>.service
# systemctl daemon-reload

# systemctl cat ssh
# systemctl cat cron
# systemctl edit <unité>
</section>

<section>
  <section>
    <h2>Postfix</h2>
  </section>
  <section>
    <h3>Installation</h3>
    <pre><code data-trim class="hljs nohighlight">
      # apt install postfix
    </code></pre>
    <h3>Configuration</h3>
    <ul>
      <li>process : /etc/postfix/master.cf</li>
      <li>options : /etc/postfix/main.cf</li>
    </ul>
  </section>
  <section>
  <pre>
<code># vim main.cf</code>
<code data-trim style="max-height: 500px">
smtpd_banner = $myhostname ESMTP mail server
biff = no
append_dot_mydomain = no
myhostname = hosting.example.com
alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = $myhostname
mydestination = $myhostname localhost.localdomain localhost
relayhost =
mynetworks = 127.0.0.0/8
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = all
inet_protocols = ipv4
disable_vrfy_command = yes
</code></pre>
</section>

<section>
<pre>
<code class="hljs nohighlight" data-trim style="max-height: 500px">
# date | mail -s test jdoe@example.com
# mailq
# qshape deferred
# postcat -vq < queue_id > > message.txt
# postsuper -d < queue_id >
# postsuper -d ALL
# postsuper -r < queue_id >
# postsuper -r ALL

# mailq | tail -n +2 | \
    awk 'BEGIN { RS = "" } /example\.com$/ { print $1 }' | \
    tr -d '*!' | postsuper -d -
</code></pre>
</section>

<section>
<h2>syslog</h2>

Rsyslog est le démon syslog par défaut sous Debian. Le protocole syslog permet de gérer la journalisation : les messages sont envoyés par diverses applications (messages kernel, user, daemon, mail, etc.) triés par une facility (LOG_KERN, LOG_CRON, LOG_DAEMON, LOG_MAIL, LOG_AUTH, etc.) et un certain niveau de severity (LOG_EMERG, LOG_ALERT, LOG_ERR, LOG_WARNING, etc.) ; ils sont reçus par un démon qui les répartit dans différents fichiers situés dans le répertoire /var/log/ ou par d’autres façons (serveur syslog distant, terminal, etc.)

# systemctl status rsyslog

# vim /etc/rsyslog.conf

*.*;auth,authpriv.none;cron,mail,local4,local5,local7.none -/var/log/syslog
cron.*      /var/log/cron.log
#mail.info  -/var/log/mail.info
#mail.warn  -/var/log/mail.warn
#mail.err   /var/log/mail.err
local0.*    /var/log/postgresql.log
local1.*    /var/log/sympa.log
local4.*    -/var/log/openldap.log
local5.*    -/var/log/haproxy.log
local7.*    -/var/log/dhcp.log

</section>

<section>
<h2>logrotate</h2>
Rotation des journaux
Le logiciel logrotate permet de gérer les journaux système et logiciel de façon précise et ordonnée. De façon quotidienne ou hebdomadaire, les journaux sont compressés et datés, avec d'éventuelles actions nécessaires (relance du service, génération de statistiques, etc.). Pour le détail, c'est le paquet logrotate qui contient des scripts lancés par la crontab du système et qui utilisent les fichiers dans le répertoire /etc/logrotate.d/.




Les journaux sont des fichiers qui contiennent des informations d'activité datée. Ils sont essentiels pour un serveur pour de nombreuses raisons : vérifier des actions passées, générer des statistiques, déboguer un programme. La vérification des actions passées est notamment importante en cas de problème (piratage, service défectueux). La justice oblige également à conserver certains journaux pendant une certaine durée. Un flou concerne ce qu'il faut réellement conserver (apparemment seules les informations d'entêtes mais pas le contenu en lui-même) et la durée (cela varie entre 3 mois, 1 an et 3 ans si l'on se base sur les lois françaises ou européennes). Des décrets d'application devraient éclaircir ces points dans les prochains mois.\\
~\\
Sous Debian, les journaux se trouvent généralement dans le répertoire \textit{/var/log}. On va distinguer les journaux systèmes et les journaux applicatifs. Les journaux systèmes sont gérés par le démon SYSLOG\footnote{\url{ftp://ftp.rfc-editor.org/in-notes/rfc3164.txt}}. Sa configuration se trouve dans le fichier \textit{syslog.conf}. Voici quelques ligne extraites de ce fichier~:
\begin{verbatim}
daemon.*                              -/var/log/daemon.log
kern.*                                -/var/log/kern.log
mail.*                                -/var/log/mail.log
*.=debug;auth,authpriv.none;news.none;mail.none  -/var/log/debug
*.emerg                               *
*.*;auth,authpriv.none                /dev/tty8
\end{verbatim}

Voici les fichiers pincipaux générés par SYSLOG : \\
~\\
\begin{itemize}
\item[\textbf{auth.log :}] authentification système (login, su, getty)
\item[\textbf{daemon.log :}] relatif aux daemons
\item[\textbf{mail.* :}] messages relatifs aux mails
\item[\textbf{kern.log :}] messages générés par le noyau
\item[\textbf{user.log :}] message généré par des programmes utilisateur
\item[\textbf{debug :}] messages de bogues
\item[\textbf{messages :}]  messages d'info
\item[\textbf{syslog :}]  tous les messages
\end{itemize}
~\\
~\\
Les journaux applicatifs sont générés par chaque application. Ils sont souvent dans un répertoire du nom de l'application situé dans \textit{/var/log}.\\
~\\
</section>

<section>
<h2>log2mail</h2>

Surveiller les journaux avec log2mail
Pour surveiller précisement un fichier journal et recevoir des alertes par mail si certains termes apparaissent dans ce fichier, vous pouvez utiliser le logiciel log2mail. Sa configuration se déroule dans le fichier /etc/log2mail/config/default. Par exemple, si vous voulez préciser que vous voulez recevoir un mail dès que le terme fatal apparaît dans le fichier /var/log/mail.log, ajoutez ces lignes :
file = /var/log/mail.log
pattern = "fatal"
mailto = maintenance@example.com
template = /etc/log2mail/template.mail-fatal
Dans ce cas, on devra avoir un fichier /etc/log2mail/template.mail-fatal qui définit la structure du mail qui sera envoyé. Voici un exemple simple :
From: %f
To: %t
Subject: [LOG2MAIL] Erreur fatale pour mail.log
Nous avons reconnu le terme "%m" dans "%F" %n fois : %l
</section>

<section>
<h2>logcheck</h2>
https://wiki.evolix.org/HowtoLogcheck
</section>

<section>
<h2>fail2ban</h2>
https://wiki.evolix.org/HowtoFail2Ban
</section>

<section>
<h2>logrotate</h2>

L'un des points essentiels est la rotation des journaux, c'est-à-dire l'action de fermer le journal actuel (et éventuellement le compresser) et d'en ouvrir un autre.
Le programme principal est logrotate
Logrotate est exécuté tous les jours (cron.daily)
https://wiki.evolix.org/HowtoLogrotate

Note : mentionner l'existence de savelog. L'option "-d" de savelog permet d'utiliser la date lors de la rotation des journaux et de ne pas les effacer. On pourra donc ajouter ses propres règles dans les scripts cron pour faire une sauvegarde distante des journaux (éventuellement dans une base de données). Pour des serveurs dédiés (applications clés), on peut augmenter la fréquence des rotations et des sauvegardes distantes, mais également utiliser des scripts afin de détecter toutes alertes ou anomalies et les envoyer par courrier électronique ou même SMS.
</section>

<section>
  <section>
    <h2>Introduction à Git</h2>
  </section>
  <section>
    <h3>Qu'est-ce que Git ?</h3>
    <p>Système de contrôle de versions, open-source, décentralisé, conçu pour être efficace et rapide.</p>
  </section>
  <section>
    <h4>Contrôle de versions</h4>
    <ul>
      <li>conserver différentes versions dans le temps</li>
      <li>naviguer dans l'historique</li>
      <li>gérer des branches</li>
      <li>travailler en équipe</li>
    </ul>
  </section>
  <section>
    <h4>outils connus ?</h4>
    <ul>
      <li>cp-old <pre>cp main.c main.c.old</pre></li>
      <li>RCS, CVS, SVN</li>
      <li>GIT, Mercurial, Bazar, Darcs, GNU Arch…</li>
      <li>Perforce, IBM Rational, Visual SourceSafe…</li>
    </ul>
  </section>
  <section>
    <h4>Open-source</h4>
    <ul>
      <li>License GPL v2</li>
      <li>Créé par Linus Torvalds pour le noyau Linux</li>
      <li>multi-plateformes</li>
    </ul>
  </section>
  <section>
    <h4>Décentralisé</h4>
    <ul>
      <li>Tout est local (le plus souvent)</li>
      <li>échanges possibles entre dépôts (FS ou réseau)</li>
      <li>tout l'historique est disponible</li>
      <li>pereine et fiable (copies autonomes et complètes)
    </ul>
  </section>
  <section>
    <h4>Rapide, efficace</h4>
    <ul>
      <li>simple base de données clés/valeurs</li>
      <li>écrit en C, très portable</li>
      <li>adapté à toutes les tailles de projets</li>
    </ul>
  </section>
  <section>
    <h3>Concepts de base</h3>
  </section>
  <section>
    <h4>Historique</h4>
    <ul>
      <li>métadonnées sur le commit</li>
      <li>liaison(s) avec le(s) parent(s)</li>
      <li>visualisation chonologique</li>
    </ul>
  </section>
  <section>
    <h4><em>commit</em>, <em>tree</em>, <em>blob</em></h4>
    <ul>
      <li>un commit pointe sur un arbre</li>
      <li>chaque élément pointe sur un autre arbre</li>
      <li>… ou sur un "blob" (contenu final)</li>
    </ul>
  </section>
  <section>
    <h4>les branches</h4>
    <ul>
      <li>la botte secrète de Git</li>
      <li>faciles à créer, fusionner, détruire</li>
      <li>éphémères ou durables</li>
      <li>locales ou partagées</li>
      <li>la base d'un workflow d'équipe</li>
    </ul>
  </section>
  <section>
    <h4>3 zones</h4>
    <ul>
      <li><em>working copy</em> : ce que voit votre éditeur</li>
      <li><em>staging area</em> : préparer des commits</li>
      <li><em>repository</em> : la base de données interne</li>
    </ul>
  </section>
  <section>
    <h4>Utilisation</h4>
    <ul>
      <li>en ligne de commande</li>
      <li>dans un outil (graphique) dédié</li>
      <li>intégré aux éditeurs…</li>
    </ul>
  </section>
  <section>
    <h3>En pratique : /etc/.git</h3>
    <p>Une <em>bonne pratique</em> Evolix.</p>
  </section>
  <section>
    <h4>Installation de Git</h4>
    <pre><code data-trim>
    $ su
    # apt install git
    # git --version
    git version 2.11.0
    </code></pre>
  </section>
  <section>
    <h4>Initialisation du dépôt</h4>
    <pre><code data-trim>
    $ cd /etc
    $ su
    # git init
    # git status
    # git add .
    # git commit -m "commit initial"
    </code></pre>
  </section>
  <section>
    <h4>Premières modifications</h4>
    <pre><code data-trim>
    # echo "127.0.0.1 foo" >> /etc/hosts
    # git status
    # git diff [HEAD]
    # git commit --all --message "Ajout de foo dans /etc/hosts"
    # git log
    # git show
    </code></pre>
  </section>
  <section>
    <h3>Aller plus loin</h3>
    <p>Le livre <strong>Pro Git</strong> est incontournable,<br>pour le débutant comme pour l'expert.</p>
    <p><a href="https://git-scm.com/book/fr/v2">git-scm.com/book/fr/v2</a></p>
  </section>
</section>

<section>
<h2>Monitoring</h2>

Il existe de nombreux programmes évolués permettant de générer des courbes et statistiques.
Citons Nagios, Munin, etc.
Le plus connu d'entre eux est certainement Nagios qui permet de surveiller de nombreux services (SMTP, POP3, HTTP, NNTP, PING, etc.) mais également les ressources (charge processeur, utilisation des disques, etc.).
La mise en place de Nagios (ou d'un équivalent) pour un nombre de serveurs dépassant la dizaine est fortement conseillée.
</section>

<section>

<h2>Sécurité</h2>
</section>

<section>
<h2>réseau / iptables</h2>

Couche physique : Ethernet
(adresses MAC)
Couche réseau : IPv4
(adressage, HostID, NetID, Masque,
Brodcast, protocole ARP, ICMP)
Couche transport : TCP, UDP
(notion de ports, mode connecté)
Couche application : HTTP, SMTP, DNS, etc.
</section>

<section>
  <section>
    <h2>Introduction à Ansible</h2>
  </section>
  <section>
    <h3>Qu'est-ce qu'Ansible ?</h3>
    <h4>Automatisation de configuration d'infrastructure et déploiement</h4>
  </section>
  <section>
      <h3>Objectifs d'Ansible</h3>
      <ul>
          <li>homogénéité</li>
          <li>fiabilité</li>
          <li>rapidité</li>
      </ul>
  </section>
  <section>
      <h4>Parfait pour</h4>
      <ul>
          <li>tâches répétitives</li>
          <li>actions urgentes</li>
          <li>demandes spécifiques</li>
      </ul>
  </section>
  <section>
      <h3>Principes fondateurs</h3>
    <ul>
      <li>Idempotence</li>
      <li>Pas d'agent</li>
      <li>Souplesse et légèreté</li>
    </ul>
  </section>
  <section>
      <h3>Installation</h3>
      <p>Paquets pour de nombreuses distributions</p>
      <pre><code class="hljs nohighlight" data-trim>$ su
# apt install ansible
# ansible --version
ansible 2.2.1.0
  config file = /etc/ansible/ansible.cfg
  configured module search path = Default w/o overrides
</code></pre>
  </section>
  <section>
      <h3>Commandes de base</h3>
      <pre><code class="hljs nohighlight" data-trim>
        $ ansible localhost --module-name ping
        $ ansible localhost --module-name ping --one-line
        $ ansible localhost --module-name setup
        $ ansible localhost --module-name setup --args "filter=ansible_mem*"
        $ ansible localhost --module-name lineinfile --args \
          "dest=/etc/hosts regexp=example.com line='192.168.0.25 example.com'"
			</code></pre>
  </section>
  <section>
      <h3>Éléments de base</h3>
  </section>
  <section>
      <h4>Modules</h4>
      <ul>
          <li>couche d'abstraction du shell</li>
          <li>homogénéité</li>
          <li>idempotence</li>
      </ul>
  </section>
  <section>
      <h4><i>Tasks</i> / <i>Handlers</i></h4>
      <ul>
          <li>invocation d'un module avec des paramètres</li>
          <li>le handler n'est exécuté qu'une fois</li>
      </ul>
  </section>
  <section>
      <h4><i>Playbooks</i></h4>
      <ul>
          <li>exécution procédurale de tâches</li>
          <li>définition du contexte</li>
          <li>orchestration complexe</li>
      </ul>
  </section>
  <section>
      <h4>Rôles</h4>
      <ul>
          <li>comme un paquet autonome</li>
          <li>contient <em>tasks</em>, <em>handlers</em>, variables, <em>templates</em>…</li>
          <li>inclus dans des <em>playbooks</em></li>
          <li>stockés localement ou récupérés dans un registre</li>
      </ul>
  </section>
  <section>
      <h4>Inventaire et variables</h4>
      <ul>
          <li>liste des serveurs</li>
          <li>moyens d'accès</li>
          <li>variables spécifiques (par hôte ou groupe)</li>
      </ul>
  </section>
  <section>
      <pre><code class="hljs nohighlight" data-trim>
				inventory/
				├── group_vars
				│   ├── all.yml
				│   ├── hypervisors.yml
				│   └── proxies.yml
				├── hosts
				├── hosts-dev
				└── host_vars
				    ├── stack01-data01.yml
				    ├── stack01-front01-web01.yml
				    └── stack01-front01.yml
		</code></pre>
  </section>
  <section>
      <pre><code class="hljs ini" data-trim style="max-height: 600px">
				kvm01 ansible_host=192.168.2.1
				kvm02 ansible_host=192.168.2.2

				stack01-front01 ansible_host=192.168.2.1 ansible_port=22020
				stack01-front01-web01 ansible_host=192.168.2.1 ansible_port=22101
				stack01-data01 ansible_host=192.168.2.1 ansible_port=22010

				[hypervisors]
				kvm01
				kvm02

				[fronts]
				stack01-front01

				[dbs]
				stack01-data01

				[web]
				stack01-front01-web01
		</code></pre>
  </section>
  <section>
      <h4>Variables</h4>
      <ul>
          <li>sources multiples (<em>facts</em> ou configuration)</li>
          <li>règles de précédence pour personnalisation</li>
      </ul>
  </section>
  <section>
      <h3>Un playbook</h3>
  </section>
  <section>
      <pre><code class="hljs yaml" data-trim>
        ---
        - hosts: localhost

          tasks:
          - name: example.com in /etc/hosts
            lineinfile:
              dest: /etc/hosts
              regexp: example.com
              line: '192.168.0.25 example.com'
              state: present
        </code></pre>
      <pre><code class="hljs bash">$ ansible-playbook playbook.yml</code></pre>
  </section>
</section>

<section>
<h2>ssh</h2>
</section>

<section>
<h2>sauvegardes</h2>
</section>

<section>
<h2>Gestion des droits</h2>
Sous les systèmes de type Unix ou Linux, il existe plusieurs types de fichiers: les fichiers, les répertoires, les liens symboliques, les fichiers-périphériques.
Un fichier appartient à un utilisateur (en fait un numéro d'utilisateur) et à un groupe (en fait un numéro de groupe).
Les 3 droits fondamentaux sont la lecture, l'écriture et l'éxecution.
Pour un fichier, ces 3 droits sont définis pour 3 catégories: l'utilisateur, le groupe et le "reste du monde". Pour chacune de ces catégories: on note les droits sous la forme rwx.
[s:sst] u:rwx g:rwx o:rwx

Commandes utiles/essentielles :
- ls -l, stat, chmod, chown, chgrp
- su, newgrp, login, who, w, w.procps
$ chmod <catégorie>+<nouveau_droit> fichier
$ chmod <nouveaux_droits> fichier
Droits pour un répertoire :
r = lister, x = traverser, w = écrire (et même effacer !!)
Droits spéciaux :
- Exécutables setuid ou setgid
- Répertoire setgid ou stickybit

Notation décimale :

777 = ?
700 = ?
600 = ?
644 = ?
755 = ?
775 = ?
701 = ?

umask :
- Pour gérer droit niveau utilisateurs : commande umask
  Fixé dans le fichier profile ou bashrc (local ou général...)
  </section>

  <section>
<h2>NFS</h2>
</section>

<section>
<h2>DRBD</h2>
</section>

<section>
<h2>LVM</h2>
</section>

<section>
<h2>Virtualisation</h2>
</section>

<section>
<h2>Conteneur</h2>
</section>

<section>
evolinux</h2>
</section>

<section>
<h2>auth</h2>
Historiquement sous Unix, l'authentification est gérée par une liste des utilisateurs avec les mots de passe chiffrés accessible à tous, à savoir le fameux fichier /etc/passwd accessible en lecture et la commande passwd « set-uid root »

- Authentification shadow recommandé
Le mot de passe chiffré est dans le fichier /etc/shadow inaccessible en lecture. Commande pour activer/désactiver l'authentification shadow :
# shadowconfig on/off

- Groupes UNIX :
Les groupes d'un système sont dans le fichier /etc/group
Programmes de gestion des utilisateurs :
Utilitaires basiques : useradd, groupadd, userdel, groupdel, usermod, groupmod, chsh, chfn (paquet passwd sous Debian)
Utilitaires convivaux : adduser, addgroup, deluser et delgroup (paquet adduser sous Debian) avec valeurs par défaut dans le fichier /etc/adduser.conf :
« Profil » pour un utilisateur créé :
Il se trouve dans le répertoire /etc/skel/

Les utilisateurs sont identifiés par leur nom de compte et par leur appartenance à  un groupe par défaut(informations dans /etc/passwd). En plus, les utilisateurs peuvent appartenir à d'autres groupes (informations /etc/group).

jdoe@serveur:~$ whoami
jdoe
jdoe@serveur:~$ groups
jdoe dialout cdrom floppy audio video plugdev
jdoe@serveur:~$ id
uid=1000(jdoe) gid=1000(jdoe) groupes=20(dialout),24(cdrom),25(floppy),29(audio),44(video),46(plugdev),1000(jdoe)
jdoe@serveur:~$

Restriction au niveau des procédures de login :


Fichier  /etc/login.defs :

FAIL_DELAY 10 \ delai minimum entre deux tentatives de login
FAILLOG_ENAB  yes \ journaliser les tentatives ratées
LOG_UNKFAIL_ENAB yes \ retenir les identifiants iconnus essayés
LOG_OK_LOGINS yes \ retenir les tentatives réussies
LOGIN_TIMEOUT  60 \ delai maximim pour authentification
CHFN_RESTRICT rwh \ restriction pour la commande chfn


Complété par... Linux-PAM (Pluggable Authentication Modules)



Le fichier /etc/shadow  contient les informations sécurisées, notamment la plus sensible : le mot de passe, mais également des paramètres d'expiration. Voir la commande vipw -s
foo:$1$mYploS2J$uSouKZPBjUF6D094HPgGj/:13853:0:99999:7:::

       ·   nom de connexion de l´utilisateur (« login »)
       ·   mot de passe chiffré
       ·   nombre de jours, comptés à partir du 1er janvier 1970,
       depuis le dernier changement de mot de passe
       ·   nombre de jours à attendre avant de pouvoir changer le mot de passe
       ·   nombre de jours après lesquels le mot de passe doit être changé
       ·   nombre de jours avant la fin de validité du mot de passe et pendant
           lesquels l´utilisateur est averti
       ·   nombre de jours après la fin de validité provoquant la désactivation du
           compte
       ·   nombre de jours, comptés à partir du 1er janvier 1970, depuis que le
           compte est désactivé
       ·   champ réservé


Politique de gestion des mots de passe

- Mot de passe aléatoire ou quasi-aléatoire
- Trace écrite bannie
- Empêcher mot de passe trop simple pour les utilisateurs: librairie cracklib
- Programme de génération de mot de passe:
  otp, apg, makepasswd, pwgen
- Programme pour cracker les mots de passe:
  John the Ripper

Qui est root ?
- UID=0
- su, su -, su -c
sudo
- Droits délégués (administration partagée, utilisation de scripts, etc.)
- Éditer les droits : commande visudo
- sudo -u, sudo sh -c,

# apt install sudo
# visudo

jdoe ALL = ALL
jdoe ALL = NOPASSWD: ALL
jdoe ALL = /usr/sbin/tcpdump
jdoe ALL = (foo) /bin/kill
jdoe ALL = (ALL) sudoedit /etc/hosts

sudo -l


- Le système de gestion des utilisateurs diffère du système d'authentification des utilisateurs
- Utilisation des UID, GID (pas de réelle nécessité d'avoir une entrée dans /etc/password !!)
- Correspondances UID<->login, GID<->group faites avec la bibliothèque libnss (Name Services Switch). C'est également le cas des noms de services, protocoles, machines (DNS). On peut d'ailleurs voir cela comme un DNS pour les UID/GID.
Voir le fichier /etc/nsswitch.conf :

passwd:         compat
group:          compat
shadow:         compat
hosts:          files dns


PAM
    Mode de fonctionnement très modulaire rendant transparent à l'application l'utilisation de tel ou tel système d'authentification.
   Des modules PAM existent pour NIS, LDAP, Kerberos, rendant ainsi les trois systèmes d'authentification interchangeables sans que cela nécessite une reconfiguration des logiciels en eux-même ou encore une recompilation des services.
- Répertoire des fichiers de configuration:
  /etc/pam.d/
- Comportement par défaut:
  /etc/pam.d/other.
- Syntaxe des fichiers
  "type" "niveau" "module" "arguments"
- /etc/security/access.conf permet de gérer les permissions de       login  (si activé dans PAM)
- /etc/security/limits.conf permet d'imposer des limites diverses   sur les groupes ou les identifiants
Syntaxe des fichiers
  "type" "niveau" "module" "arguments"

"type" peut être :
auth : authentification
account : vérification des types de services autorisés
session : tâches à effectuer avant/après l'accès
password : mécanismes d'authentification

"niveau" peut être :
required : le succès à cette étape est nécessaire
requisite : le succès est nécessaire et l'accès est refusé en cas d'erreur
sufficient : le succès à cette étape suffit
optional : l'accès pourra etre refusé en fonction d'autres paramètres

Exemple /etc/pam.d/login :
           # Authenticate the user
           auth       required   pam_unix.so
           # Ensure users account and password are still active
           account    required   pam_unix.so
           # Change the users password, but at first check the strength
           # with pam_cracklib(8)
           password   required   pam_cracklib.so retry=3 minlen=6 difok=3
           password   required   pam_unix.so use_authtok nullok md5
           session    required   pam_unix.so


              ACL/QUOTA
              TODO
            </section>

            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>

            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
